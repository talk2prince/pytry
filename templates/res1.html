<div class=\"document\"><p>integrate(f, var, ...)</p><p>Compute definite or indefinite integral of one or more variables using Risch-Norman algorithm and table lookup. This procedure is able to handle elementary algebraic and transcendental functions and also a huge class of special functions, including Airy,Bessel, Whittaker and Lambert.</p><p>var can be:</p><ul><li><p class=\"first\">a symbol -- indefinite integration</p></li><li><dl class=\"first docutils\"><dt>a tuple (symbol, a) -- indefinite integration with result</dt><dd><p class=\"first last\"><dt>given with <cite>a</cite> replacing <cite>symbol</cite></dt></p></dd></dl></li><li><p class=\"first\">a tuple (symbol, a, b)-- definite integration</p></li></ul><p>Several variables can be specified, in which case the result is multiple integration. (If var is omitted and the integrand is univariate, the indefinite integral in that variable will be performed.)</p><p>Indefinite integrals are returned without terms that are independent of the integration variables. (see examples)</p><p>Definite improper integrals often entail delicate convergence conditions. Pass conds='piecewise', 'separate' or 'none' to have these returned, respectively, as a Piecewise function, as a separate result (i.e. result will be a tuple), or not at all (default is 'piecewise').</p><p><strong>Strategy</strong></p><p>SymPy uses various approaches to definite integration. One method is to find an antiderivative for the integrand, and then use the fundamental theorem of calculus. Various functions are implemented to integrate polynomial, rational and trigonometric functions, and integrands containing DiracDelta terms.</p><p>SymPy also implements the part of the Risch algorithm, which is a decision procedure for integrating elementary functions, i.e., the algorithm can either find an elementary antiderivative, or prove that one does not exist.  There is also a (very successful, albeit somewhat slow) general implementation of the heuristic Risch algorithm.  This algorithm will eventually be phased out as more of the full Risch algorithm is implemented. See the docstring of Integral._eval_integral() for more details on computing the antiderivative using algebraic methods.</p><p>The option risch=True can be used to use only the (full) Risch algorithm.This is useful if you want to know if an elementary function has an elementary antiderivative.  If the indefinite Integral returned by this function is an instance of NonElementaryIntegral, that means that theRisch algorithm has proven that integral to be non-elementary.  Note that by default, additional methods (such as the Meijer G method outlined below) are tried on these integrals, as they may be expressible in terms of special functions, so if you only care about elementary answers, use risch=True.  Also note that an unevaluated Integral returned by this function is not necessarily a NonElementaryIntegral, even with risch=True,as it may just be an indication that the particular part of the Risch algorithm needed to integrate that function is not yet implemented.</p><p>Another family of strategies comes from re-writing the integrand in terms of so-called Meijer G-functions. Indefinite integrals of a single G-function can always be computed, and the definite integral of a product of two G-functions can be computed from zero to infinity. Various strategies are implemented to rewrite integrands as G-functions, and use this information to compute integrals (see the <tt class=\"docutils literal\">meijerint</tt> module).</p><p>The option manual=True can be used to use only an algorithm that tries to mimic integration by hand. This algorithm does not handle as many integrands as the other algorithms implemented but may return results in a more familiar form. The <tt class=\"docutils literal\">manualintegrate</tt> module has functions that return the steps used (see the module docstring for more information).</p><p>In general, the algebraic methods work best for computing antiderivatives of (possibly complicated) combinations of elementary functions. The G-function methods work best for computing definite integrals from zero to infinity of moderately complicated combinations of special functions, or indefinite integrals of very simple combinations of special functions.</p><p>The strategy employed by the integration code is as follows:</p><ul class=\"simple\"><li>If computing a definite integral, and both limits are real, and at least one limit is +- oo, try the G-function method of definite integration first.</li><li>Try to find an antiderivative, using all available methods, ordered by performance (that is try fastest method first, slowest last; in particular polynomial integration is tried first, meijerg-functions second to last, and heuristic risch last).</li><li>If still not successful, try G-functions irrespective of the limits.</li></ul><p>The option meijerg=True, False, None can be used to, respectively:always use G-function methods and no others, never use G-function methods, or use all available methods (in order as described above).It defaults to None.</p><div class=\"section\" id=\"examples\"><h1>Examples</h1><pre class=\"doctest-block\">&gt;&gt;&gt; from sympy import integrate, log, exp, oo&gt;&gt;&gt; from sympy.abc import a, x, y</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(x*y, x) x**2*y/2</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(log(x), x) x*log(x) - x</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(log(x), (x, 1, a)) a*log(a) - a + 1</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(x) x**2/2</pre><p>Terms that are independent of x are dropped by indefinite integration:</p><pre class=\"doctest-block\">&gt;&gt;&gt; from sympy import sqrt&gt;&gt;&gt; integrate(sqrt(1 + x), (x, 0, x))2*(x + 1)**(3/2)/3 - 2/3&gt;&gt;&gt; integrate(sqrt(1 + x), x)2*(x + 1)**(3/2)/3</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(x*y) Traceback (most recent call last):...ValueError: specify integration variables to integrate x*y</pre><p>Note that <tt class=\"docutils literal\">integrate(x)</tt> syntax is meant only for convenience in interactive sessions and should be avoided in library code.</p><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'Piecewise((gamma(a + 1), -re(a) &lt; 1),   (Integral(x**a*exp(-x), (x, 0, oo)), True))</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo), conds='none')gamma(a + 1)</pre><pre class=\"doctest-block\">&gt;&gt;&gt; integrate(x**a*exp(-x), (x, 0, oo), conds='separate')(gamma(a + 1), -re(a) &lt; 1)</pre></div><div class=\"section\" id=\"see-also\"><h1>See Also</h1><p>Integral, Integral.doit</p></div></div>